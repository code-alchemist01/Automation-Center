#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>
#include <lmcons.h>
#include <direct.h>
#include "../../include/core.h"
#include "../../include/logger.h"

#define MAX_REPORT_SIZE 50000
#define REPORTS_DIR "reports"
#define MAX_FILENAME_LEN 1024

// Function prototypes
void show_reports_menu();
void generate_system_report();
void generate_security_html_report();
void generate_performance_report();
void generate_backup_report();
void generate_network_report();
void generate_comprehensive_report();
void view_existing_reports();
void export_report_to_pdf();

// Helper functions
void create_reports_directory();
void write_html_header(FILE* file, const char* title);
void write_html_footer(FILE* file);
void get_system_info_for_report(char* buffer, int bufferSize);
void get_disk_info_for_report(char* buffer, int bufferSize);
void get_memory_info_for_report(char* buffer, int bufferSize);
void get_network_info_for_report(char* buffer, int bufferSize);
void get_process_info_for_report(char* buffer, int bufferSize);
void get_log_analysis_for_report(char* buffer, int bufferSize);
void get_backup_status_for_report(char* buffer, int bufferSize);

void run_reports() {
    log_message(LOG_INFO, "Reports module started");
    create_reports_directory();
    
    int choice;
    do {
        show_reports_menu();
        printf("Se√ßiminizi yapƒ±n (0-8): ");
        
        if (scanf("%d", &choice) != 1) {
            printf("Ge√ßersiz giri≈ü! L√ºtfen bir sayƒ± girin.\n");
            while (getchar() != '\n'); // Clear input buffer
            continue;
        }
        
        switch (choice) {
            case 1:
                generate_system_report();
                break;
            case 2:
                generate_security_html_report();
                break;
            case 3:
                generate_performance_report();
                break;
            case 4:
                generate_backup_report();
                break;
            case 5:
                generate_network_report();
                break;
            case 6:
                generate_comprehensive_report();
                break;
            case 7:
                view_existing_reports();
                break;
            case 8:
                export_report_to_pdf();
                break;
            case 0:
                printf("Ana men√ºye d√∂n√ºl√ºyor...\n");
                break;
            default:
                printf("Ge√ßersiz se√ßim! L√ºtfen 0-8 arasƒ±nda bir sayƒ± girin.\n");
        }
        
        if (choice != 0) {
            printf("\nDevam etmek i√ßin Enter tu≈üuna basƒ±n...");
            getchar();
            getchar();
        }
        
    } while (choice != 0);
    
    log_message(LOG_INFO, "Reports module ended");
}

void show_reports_menu() {
    system("cls");
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                      RAPORLAR                                ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë  1. Sistem Raporu Olu≈ütur                                   ‚ïë\n");
    printf("‚ïë  2. G√ºvenlik Raporu Olu≈ütur                                 ‚ïë\n");
    printf("‚ïë  3. Performans Raporu Olu≈ütur                               ‚ïë\n");
    printf("‚ïë  4. Yedekleme Raporu Olu≈ütur                                ‚ïë\n");
    printf("‚ïë  5. Aƒü Raporu Olu≈ütur                                       ‚ïë\n");
    printf("‚ïë  6. Kapsamlƒ± Rapor Olu≈ütur                                  ‚ïë\n");
    printf("‚ïë  7. Mevcut Raporlarƒ± G√∂r√ºnt√ºle                              ‚ïë\n");
    printf("‚ïë  8. Raporu PDF'e Aktar                                      ‚ïë\n");
    printf("‚ïë  0. Ana Men√ºye D√∂n                                          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
}

void create_reports_directory() {
    _mkdir(REPORTS_DIR);
}

void generate_system_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    Sƒ∞STEM RAPORU                            ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    // Generate filename with timestamp
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/system_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("Rapor dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create system report file: %s", filename);
        return;
    }
    
    write_html_header(file, "Sistem Raporu");
    
    // System Information Section
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üñ•Ô∏è Sistem Bilgileri</h2>\n");
    
    char sysInfo[2048];
    get_system_info_for_report(sysInfo, sizeof(sysInfo));
    fprintf(file, "%s", sysInfo);
    
    fprintf(file, "</div>\n");
    
    // Memory Information Section
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíæ Bellek Bilgileri</h2>\n");
    
    char memInfo[1024];
    get_memory_info_for_report(memInfo, sizeof(memInfo));
    fprintf(file, "%s", memInfo);
    
    fprintf(file, "</div>\n");
    
    // Disk Information Section
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíø Disk Bilgileri</h2>\n");
    
    char diskInfo[2048];
    get_disk_info_for_report(diskInfo, sizeof(diskInfo));
    fprintf(file, "%s", diskInfo);
    
    fprintf(file, "</div>\n");
    
    // Process Information Section
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>‚öôÔ∏è √áalƒ±≈üan S√ºre√ßler (Top 10)</h2>\n");
    
    char processInfo[4096];
    get_process_info_for_report(processInfo, sizeof(processInfo));
    fprintf(file, "%s", processInfo);
    
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("Sistem raporu olu≈üturuldu: %s\n", filename);
    printf("Raporu g√∂r√ºnt√ºlemek i√ßin dosyayƒ± web tarayƒ±cƒ±sƒ±nda a√ßƒ±n.\n");
    
    // Open the report automatically
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "System report generated: %s", filename);
}

void generate_security_html_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                   G√úVENLƒ∞K RAPORU                           ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/security_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("G√ºvenlik raporu dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create security report file: %s", filename);
        return;
    }
    
    write_html_header(file, "G√ºvenlik Raporu");
    
    // Windows Defender Status
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üõ°Ô∏è Windows Defender Durumu</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    // Check Windows Defender status
    FILE* cmd = _popen("powershell Get-MpComputerStatus | Select-Object AntivirusEnabled,RealTimeProtectionEnabled,IoavProtectionEnabled", "r");
    if (cmd) {
        char buffer[1024];
        fprintf(file, "<pre>\n");
        while (fgets(buffer, sizeof(buffer), cmd)) {
            fprintf(file, "%s", buffer);
        }
        fprintf(file, "</pre>\n");
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // Firewall Status
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üî• G√ºvenlik Duvarƒ± Durumu</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    cmd = _popen("netsh advfirewall show allprofiles state", "r");
    if (cmd) {
        char buffer[1024];
        fprintf(file, "<pre>\n");
        while (fgets(buffer, sizeof(buffer), cmd)) {
            fprintf(file, "%s", buffer);
        }
        fprintf(file, "</pre>\n");
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // User Account Control
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üë§ Kullanƒ±cƒ± Hesap Kontrol√º (UAC)</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    // Check UAC status from registry
    HKEY hKey;
    DWORD uacValue = 0;
    DWORD dataSize = sizeof(DWORD);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", 
                     0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        
        if (RegQueryValueEx(hKey, "EnableLUA", NULL, NULL, (LPBYTE)&uacValue, &dataSize) == ERROR_SUCCESS) {
            fprintf(file, "<p><strong>UAC Durumu:</strong> %s</p>\n", 
                    uacValue ? "Etkin" : "Devre Dƒ±≈üƒ±");
        }
        
        RegCloseKey(hKey);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // Recent Security Events
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üìã Son G√ºvenlik Olaylarƒ±</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    cmd = _popen("powershell \"Get-EventLog -LogName Security -Newest 10 | Select-Object TimeGenerated,EventID,EntryType,Message | ConvertTo-Html -Fragment\"", "r");
    if (cmd) {
        char buffer[1024];
        while (fgets(buffer, sizeof(buffer), cmd)) {
            fprintf(file, "%s", buffer);
        }
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // Network Security
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üåê Aƒü G√ºvenliƒüi</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    cmd = _popen("netstat -an | findstr LISTENING", "r");
    if (cmd) {
        char buffer[1024];
        fprintf(file, "<h3>Dinlenen Portlar:</h3>\n");
        fprintf(file, "<pre>\n");
        while (fgets(buffer, sizeof(buffer), cmd)) {
            fprintf(file, "%s", buffer);
        }
        fprintf(file, "</pre>\n");
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("G√ºvenlik raporu olu≈üturuldu: %s\n", filename);
    
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "Security report generated: %s", filename);
}

void generate_performance_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                  PERFORMANS RAPORU                          ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/performance_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("Performans raporu dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create performance report file: %s", filename);
        return;
    }
    
    write_html_header(file, "Performans Raporu");
    
    // CPU Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üñ•Ô∏è ƒ∞≈ülemci Bilgileri</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    FILE* cmd = _popen("wmic cpu get name,maxclockspeed,numberofcores,numberoflogicalprocessors /format:list", "r");
    if (cmd) {
        char buffer[1024];
        fprintf(file, "<pre>\n");
        while (fgets(buffer, sizeof(buffer), cmd)) {
            if (strlen(buffer) > 1) {
                fprintf(file, "%s", buffer);
            }
        }
        fprintf(file, "</pre>\n");
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // Memory Performance
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíæ Bellek Performansƒ±</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    if (GlobalMemoryStatusEx(&memInfo)) {
        fprintf(file, "<table border='1' style='border-collapse: collapse; width: 100%%;'>\n");
        fprintf(file, "<tr><th>√ñzellik</th><th>Deƒüer</th></tr>\n");
        fprintf(file, "<tr><td>Toplam Fiziksel Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullTotalPhys / (1024*1024*1024));
        fprintf(file, "<tr><td>Kullanƒ±labilir Fiziksel Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullAvailPhys / (1024*1024*1024));
        fprintf(file, "<tr><td>Bellek Kullanƒ±m Oranƒ±</td><td>%d%%</td></tr>\n", 
                memInfo.dwMemoryLoad);
        fprintf(file, "<tr><td>Toplam Sanal Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullTotalVirtual / (1024*1024*1024));
        fprintf(file, "<tr><td>Kullanƒ±labilir Sanal Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullAvailVirtual / (1024*1024*1024));
        fprintf(file, "</table>\n");
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // Disk Performance
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíø Disk Performansƒ±</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    cmd = _popen("wmic logicaldisk get size,freespace,caption /format:list", "r");
    if (cmd) {
        char buffer[1024];
        fprintf(file, "<table border='1' style='border-collapse: collapse; width: 100%%;'>\n");
        fprintf(file, "<tr><th>S√ºr√ºc√º</th><th>Toplam Alan</th><th>Bo≈ü Alan</th><th>Kullanƒ±m Oranƒ±</th></tr>\n");
        
        char caption[10] = "";
        char size[50] = "";
        char freespace[50] = "";
        
        while (fgets(buffer, sizeof(buffer), cmd)) {
            if (strstr(buffer, "Caption=")) {
                sscanf(buffer, "Caption=%s", caption);
            } else if (strstr(buffer, "FreeSpace=")) {
                sscanf(buffer, "FreeSpace=%s", freespace);
            } else if (strstr(buffer, "Size=")) {
                sscanf(buffer, "Size=%s", size);
                
                if (strlen(caption) > 0 && strlen(size) > 0 && strlen(freespace) > 0) {
                    long long totalSize = atoll(size);
                    long long freeSize = atoll(freespace);
                    long long usedSize = totalSize - freeSize;
                    double usagePercent = (double)usedSize / totalSize * 100;
                    
                    fprintf(file, "<tr><td>%s</td><td>%.2f GB</td><td>%.2f GB</td><td>%.1f%%</td></tr>\n",
                            caption, 
                            (double)totalSize / (1024*1024*1024),
                            (double)freeSize / (1024*1024*1024),
                            usagePercent);
                    
                    // Reset for next iteration
                    caption[0] = '\0';
                    size[0] = '\0';
                    freespace[0] = '\0';
                }
            }
        }
        
        fprintf(file, "</table>\n");
        _pclose(cmd);
    }
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // System Uptime
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>‚è∞ Sistem √áalƒ±≈üma S√ºresi</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    
    DWORD uptime = GetTickCount();
    DWORD days = uptime / (1000 * 60 * 60 * 24);
    DWORD hours = (uptime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60);
    DWORD minutes = (uptime % (1000 * 60 * 60)) / (1000 * 60);
    
    fprintf(file, "<p><strong>Sistem √áalƒ±≈üma S√ºresi:</strong> %d g√ºn, %d saat, %d dakika</p>\n", 
            days, hours, minutes);
    
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("Performans raporu olu≈üturuldu: %s\n", filename);
    
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "Performance report generated: %s", filename);
}

void generate_backup_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                  YEDEKLEME RAPORU                           ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/backup_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("Yedekleme raporu dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create backup report file: %s", filename);
        return;
    }
    
    write_html_header(file, "Yedekleme Raporu");
    
    // Backup Status
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíæ Yedekleme Durumu</h2>\n");
    
    char backupInfo[2048];
    get_backup_status_for_report(backupInfo, sizeof(backupInfo));
    fprintf(file, "%s", backupInfo);
    
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("Yedekleme raporu olu≈üturuldu: %s\n", filename);
    
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "Backup report generated: %s", filename);
}

void generate_network_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                     Aƒû RAPORU                               ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/network_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("Aƒü raporu dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create network report file: %s", filename);
        return;
    }
    
    write_html_header(file, "Aƒü Raporu");
    
    // Network Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üåê Aƒü Bilgileri</h2>\n");
    
    char networkInfo[4096];
    get_network_info_for_report(networkInfo, sizeof(networkInfo));
    fprintf(file, "%s", networkInfo);
    
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("Aƒü raporu olu≈üturuldu: %s\n", filename);
    
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "Network report generated: %s", filename);
}

void generate_comprehensive_report() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                  KAPSAMLI RAPOR                             ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    printf("Kapsamlƒ± rapor olu≈üturuluyor... Bu i≈ülem birka√ß dakika s√ºrebilir.\n");
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    char filename[MAX_PATH_LEN];
    sprintf(filename, "%s/comprehensive_report_%04d%02d%02d_%02d%02d%02d.html",
            REPORTS_DIR, t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
            t->tm_hour, t->tm_min, t->tm_sec);
    
    FILE* file = fopen(filename, "w");
    if (!file) {
        printf("Kapsamlƒ± rapor dosyasƒ± olu≈üturulamadƒ±!\n");
        log_message(LOG_ERROR, "Failed to create comprehensive report file: %s", filename);
        return;
    }
    
    write_html_header(file, "Kapsamlƒ± Sistem Raporu");
    
    // Executive Summary
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üìä Y√∂netici √ñzeti</h2>\n");
    fprintf(file, "<div class='info-box'>\n");
    fprintf(file, "<p>Bu rapor %02d.%02d.%04d tarihinde %02d:%02d:%02d saatinde olu≈üturulmu≈ütur.</p>\n",
            t->tm_mday, t->tm_mon + 1, t->tm_year + 1900,
            t->tm_hour, t->tm_min, t->tm_sec);
    fprintf(file, "<p>Sistem durumu, g√ºvenlik, performans ve aƒü bilgileri a≈üaƒüƒ±da detaylandƒ±rƒ±lmƒ±≈ütƒ±r.</p>\n");
    fprintf(file, "</div>\n");
    fprintf(file, "</div>\n");
    
    // System Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üñ•Ô∏è Sistem Bilgileri</h2>\n");
    char sysInfo[2048];
    get_system_info_for_report(sysInfo, sizeof(sysInfo));
    fprintf(file, "%s", sysInfo);
    fprintf(file, "</div>\n");
    
    // Memory Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíæ Bellek Durumu</h2>\n");
    char memInfo[1024];
    get_memory_info_for_report(memInfo, sizeof(memInfo));
    fprintf(file, "%s", memInfo);
    fprintf(file, "</div>\n");
    
    // Disk Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíø Disk Durumu</h2>\n");
    char diskInfo[2048];
    get_disk_info_for_report(diskInfo, sizeof(diskInfo));
    fprintf(file, "%s", diskInfo);
    fprintf(file, "</div>\n");
    
    // Network Information
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üåê Aƒü Durumu</h2>\n");
    char networkInfo[4096];
    get_network_info_for_report(networkInfo, sizeof(networkInfo));
    fprintf(file, "%s", networkInfo);
    fprintf(file, "</div>\n");
    
    // Log Analysis
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üìã Log Analizi</h2>\n");
    char logInfo[2048];
    get_log_analysis_for_report(logInfo, sizeof(logInfo));
    fprintf(file, "%s", logInfo);
    fprintf(file, "</div>\n");
    
    // Backup Status
    fprintf(file, "<div class='section'>\n");
    fprintf(file, "<h2>üíæ Yedekleme Durumu</h2>\n");
    char backupInfo[2048];
    get_backup_status_for_report(backupInfo, sizeof(backupInfo));
    fprintf(file, "%s", backupInfo);
    fprintf(file, "</div>\n");
    
    write_html_footer(file);
    fclose(file);
    
    printf("Kapsamlƒ± rapor olu≈üturuldu: %s\n", filename);
    
    char command[MAX_PATH_LEN + 10];
    sprintf(command, "start %s", filename);
    system(command);
    
    log_message(LOG_INFO, "Comprehensive report generated: %s", filename);
}

void view_existing_reports() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                 MEVCUT RAPORLAR                             ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    WIN32_FIND_DATA findFileData;
    HANDLE hFind;
    char searchPath[MAX_PATH_LEN];
    
    sprintf(searchPath, "%s\\*.html", REPORTS_DIR);
    
    hFind = FindFirstFile(searchPath, &findFileData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        printf("Hen√ºz olu≈üturulmu≈ü rapor bulunamadƒ±.\n");
        return;
    }
    
    printf("Mevcut raporlar:\n");
    printf("================\n");
    
    int count = 0;
    do {
        if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            count++;
            
            // Get file size
            LARGE_INTEGER fileSize;
            fileSize.LowPart = findFileData.nFileSizeLow;
            fileSize.HighPart = findFileData.nFileSizeHigh;
            
            // Convert file time to local time
            FILETIME localFileTime;
            SYSTEMTIME systemTime;
            FileTimeToLocalFileTime(&findFileData.ftLastWriteTime, &localFileTime);
            FileTimeToSystemTime(&localFileTime, &systemTime);
            
            printf("%d. %s\n", count, findFileData.cFileName);
            printf("   Boyut: %.2f KB\n", (double)fileSize.QuadPart / 1024);
            printf("   Tarih: %02d.%02d.%04d %02d:%02d:%02d\n",
                   systemTime.wDay, systemTime.wMonth, systemTime.wYear,
                   systemTime.wHour, systemTime.wMinute, systemTime.wSecond);
            printf("   ---\n");
        }
    } while (FindNextFile(hFind, &findFileData) != 0);
    
    FindClose(hFind);
    
    if (count == 0) {
        printf("Hen√ºz olu≈üturulmu≈ü rapor bulunamadƒ±.\n");
    } else {
        printf("\nToplam %d rapor bulundu.\n", count);
        printf("\nBir raporu a√ßmak istiyor musunuz? (E/H): ");
        
        char choice;
        scanf(" %c", &choice);
        
        if (choice == 'E' || choice == 'e') {
            printf("A√ßƒ±lacak rapor numarasƒ±: ");
            int reportNum;
            scanf("%d", &reportNum);
            
            if (reportNum > 0 && reportNum <= count) {
                // Find the selected report
                hFind = FindFirstFile(searchPath, &findFileData);
                int currentCount = 0;
                
                do {
                    if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        currentCount++;
                        if (currentCount == reportNum) {
                            char fullPath[MAX_PATH_LEN];
                            sprintf(fullPath, "%s\\%s", REPORTS_DIR, findFileData.cFileName);
                            
                            char command[MAX_PATH_LEN + 10];
                            sprintf(command, "start %s", fullPath);
                            system(command);
                            
                            printf("Rapor a√ßƒ±lƒ±yor: %s\n", findFileData.cFileName);
                            break;
                        }
                    }
                } while (FindNextFile(hFind, &findFileData) != 0);
                
                FindClose(hFind);
            } else {
                printf("Ge√ßersiz rapor numarasƒ±!\n");
            }
        }
    }
    
    log_message(LOG_INFO, "Existing reports viewed, found %d reports", count);
}

int check_wkhtmltopdf_available() {
    // Check if wkhtmltopdf is available by trying to run it with --version
    int result = system("wkhtmltopdf --version >nul 2>&1");
    return (result == 0);
}

void open_html_in_browser(const char* htmlPath) {
    char command[MAX_PATH_LEN + 20];
    sprintf(command, "start \"\" \"%s\"", htmlPath);
    system(command);
}

void export_report_to_pdf() {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                 PDF'E AKTAR                                 ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    // Check if wkhtmltopdf is available
    int wkhtmltopdf_available = check_wkhtmltopdf_available();
    
    if (!wkhtmltopdf_available) {
        printf("‚ö†Ô∏è  wkhtmltopdf aracƒ± bulunamadƒ±!\n\n");
        printf("PDF d√∂n√º≈üt√ºrme se√ßenekleri:\n");
        printf("1. HTML raporunu tarayƒ±cƒ±da a√ß ve manuel PDF'e d√∂n√º≈üt√ºr\n");
        printf("2. wkhtmltopdf y√ºkle ve tekrar dene\n");
        printf("3. ƒ∞ptal et\n\n");
        printf("Se√ßiminiz (1-3): ");
        
        int choice;
        scanf("%d", &choice);
        
        if (choice == 3) {
            return;
        } else if (choice == 2) {
            printf("\nwkhtmltopdf y√ºklemek i√ßin:\n");
            printf("1. https://wkhtmltopdf.org/downloads.html adresini ziyaret edin\n");
            printf("2. Windows s√ºr√ºm√ºn√º indirin ve y√ºkleyin\n");
            printf("3. Sistem PATH'ine eklendiƒüinden emin olun\n");
            printf("\nY√ºkleme tamamlandƒ±ktan sonra bu √∂zelliƒüi tekrar deneyin.\n");
            return;
        }
        // choice == 1, continue to open in browser
    }
    
    // List HTML reports
    WIN32_FIND_DATA findFileData;
    HANDLE hFind;
    char searchPath[MAX_PATH_LEN];
    
    sprintf(searchPath, "%s\\*.html", REPORTS_DIR);
    hFind = FindFirstFile(searchPath, &findFileData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        printf("‚ùå D√∂n√º≈üt√ºr√ºlecek HTML raporu bulunamadƒ±.\n");
        printf("√ñnce bir rapor olu≈üturun.\n");
        return;
    }
    
    printf("\nüìÑ Mevcut HTML raporlarƒ±:\n");
    printf("========================\n");
    
    int count = 0;
    char reportFiles[50][MAX_FILENAME_LEN]; // Store filenames
    
    do {
        if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            count++;
            strcpy(reportFiles[count-1], findFileData.cFileName);
            printf("%d. %s\n", count, findFileData.cFileName);
        }
    } while (FindNextFile(hFind, &findFileData) != 0);
    
    FindClose(hFind);
    
    printf("\nD√∂n√º≈üt√ºr√ºlecek rapor numarasƒ± (1-%d): ", count);
    int reportNum;
    scanf("%d", &reportNum);
    
    if (reportNum < 1 || reportNum > count) {
        printf("‚ùå Ge√ßersiz rapor numarasƒ±!\n");
        return;
    }
    
    char htmlPath[MAX_PATH_LEN];
    char pdfPath[MAX_PATH_LEN];
    
    sprintf(htmlPath, "%s\\%s", REPORTS_DIR, reportFiles[reportNum-1]);
    
    // Create PDF filename
    strcpy(pdfPath, htmlPath);
    char* ext = strrchr(pdfPath, '.');
    if (ext) {
        strcpy(ext, ".pdf");
    }
    
    if (wkhtmltopdf_available) {
        // Try to convert using wkhtmltopdf
        char command[MAX_PATH_LEN * 2 + 100];
        sprintf(command, "wkhtmltopdf --page-size A4 --margin-top 0.75in --margin-right 0.75in --margin-bottom 0.75in --margin-left 0.75in \"%s\" \"%s\"", htmlPath, pdfPath);
        
        printf("\nüîÑ PDF d√∂n√º≈üt√ºrme i≈ülemi ba≈ülatƒ±lƒ±yor...\n");
        
        int result = system(command);
        if (result == 0) {
            printf("‚úÖ PDF ba≈üarƒ±yla olu≈üturuldu: %s\n", pdfPath);
            log_message(LOG_INFO, "Report converted to PDF: %s", pdfPath);
            
            printf("\nPDF dosyasƒ±nƒ± a√ßmak istiyor musunuz? (E/H): ");
            char openChoice;
            scanf(" %c", &openChoice);
            if (openChoice == 'E' || openChoice == 'e') {
                char openCommand[MAX_PATH_LEN + 20];
                sprintf(openCommand, "start \"\" \"%s\"", pdfPath);
                system(openCommand);
            }
        } else {
            printf("‚ùå PDF d√∂n√º≈üt√ºrme ba≈üarƒ±sƒ±z!\n");
            printf("HTML dosyasƒ±nƒ± tarayƒ±cƒ±da a√ßƒ±p manuel olarak PDF'e d√∂n√º≈üt√ºrmeyi deneyin.\n");
            log_message(LOG_WARNING, "PDF conversion failed for: %s", htmlPath);
            
            printf("\nHTML dosyasƒ±nƒ± tarayƒ±cƒ±da a√ßmak istiyor musunuz? (E/H): ");
            char openChoice;
            scanf(" %c", &openChoice);
            if (openChoice == 'E' || openChoice == 'e') {
                open_html_in_browser(htmlPath);
                printf("HTML raporu tarayƒ±cƒ±da a√ßƒ±ldƒ±. Ctrl+P ile yazdƒ±rabilir ve PDF olarak kaydedebilirsiniz.\n");
            }
        }
    } else {
        // Open in browser for manual conversion
        printf("\nüåê HTML raporu tarayƒ±cƒ±da a√ßƒ±lƒ±yor...\n");
        open_html_in_browser(htmlPath);
        printf("‚úÖ HTML raporu tarayƒ±cƒ±da a√ßƒ±ldƒ±.\n");
        printf("üìù PDF'e d√∂n√º≈üt√ºrmek i√ßin:\n");
        printf("   1. Ctrl+P tu≈ülarƒ±na basƒ±n\n");
        printf("   2. 'Hedef' olarak 'PDF olarak kaydet' se√ßin\n");
        printf("   3. Kaydet butonuna tƒ±klayƒ±n\n");
        log_message(LOG_INFO, "HTML report opened in browser for manual PDF conversion: %s", htmlPath);
    }
}

// Helper function implementations
void write_html_header(FILE* file, const char* title) {
    fprintf(file, "<!DOCTYPE html>\n");
    fprintf(file, "<html lang='tr'>\n");
    fprintf(file, "<head>\n");
    fprintf(file, "    <meta charset='UTF-8'>\n");
    fprintf(file, "    <meta name='viewport' content='width=device-width, initial-scale=1.0'>\n");
    fprintf(file, "    <title>%s</title>\n", title);
    fprintf(file, "    <style>\n");
    fprintf(file, "        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }\n");
    fprintf(file, "        .container { max-width: 1200px; margin: 0 auto; background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.1); }\n");
    fprintf(file, "        h1 { color: #2c3e50; text-align: center; border-bottom: 3px solid #3498db; padding-bottom: 10px; }\n");
    fprintf(file, "        h2 { color: #34495e; border-left: 4px solid #3498db; padding-left: 15px; }\n");
    fprintf(file, "        .section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }\n");
    fprintf(file, "        .info-box { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; }\n");
    fprintf(file, "        table { width: 100%%; border-collapse: collapse; margin: 15px 0; }\n");
    fprintf(file, "        th, td { padding: 12px; text-align: left; border: 1px solid #ddd; }\n");
    fprintf(file, "        th { background-color: #3498db; color: white; }\n");
    fprintf(file, "        tr:nth-child(even) { background-color: #f2f2f2; }\n");
    fprintf(file, "        .timestamp { text-align: center; color: #7f8c8d; font-style: italic; margin-top: 30px; }\n");
    fprintf(file, "        pre { background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto; }\n");
    fprintf(file, "    </style>\n");
    fprintf(file, "</head>\n");
    fprintf(file, "<body>\n");
    fprintf(file, "    <div class='container'>\n");
    fprintf(file, "        <h1>%s</h1>\n", title);
    
    // Add timestamp
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    fprintf(file, "        <div class='timestamp'>Rapor Tarihi: %02d.%02d.%04d %02d:%02d:%02d</div>\n",
            t->tm_mday, t->tm_mon + 1, t->tm_year + 1900,
            t->tm_hour, t->tm_min, t->tm_sec);
}

void write_html_footer(FILE* file) {
    fprintf(file, "        <div class='timestamp'>\n");
    fprintf(file, "            <p>Bu rapor Sistem Otomasyon Merkezi tarafƒ±ndan otomatik olarak olu≈üturulmu≈ütur.</p>\n");
    fprintf(file, "        </div>\n");
    fprintf(file, "    </div>\n");
    fprintf(file, "</body>\n");
    fprintf(file, "</html>\n");
}

void get_system_info_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    
    // Get Windows version
    OSVERSIONINFOEX osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    
    if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
        char temp[500];
        sprintf(temp, "<p><strong>ƒ∞≈ületim Sistemi:</strong> Windows %d.%d Build %d</p>\n", 
                osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
        strcat(buffer, temp);
        
        sprintf(temp, "<p><strong>Service Pack:</strong> %s</p>\n", osvi.szCSDVersion);
        strcat(buffer, temp);
    }
    
    // Get computer name
    char computerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = sizeof(computerName);
    if (GetComputerName(computerName, &size)) {
        char temp[200];
        sprintf(temp, "<p><strong>Bilgisayar Adƒ±:</strong> %s</p>\n", computerName);
        strcat(buffer, temp);
    }
    
    // Get user name
    char userName[UNLEN + 1];
    size = sizeof(userName);
    if (GetUserName(userName, &size)) {
        char temp[200];
        sprintf(temp, "<p><strong>Kullanƒ±cƒ± Adƒ±:</strong> %s</p>\n", userName);
        strcat(buffer, temp);
    }
    
    // Get processor information
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);
    char temp[200];
    sprintf(temp, "<p><strong>ƒ∞≈ülemci Sayƒ±sƒ±:</strong> %d</p>\n", sysInfo.dwNumberOfProcessors);
    strcat(buffer, temp);
    
    strcat(buffer, "</div>\n");
}

void get_memory_info_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    
    MEMORYSTATUSEX memInfo;
    memInfo.dwLength = sizeof(MEMORYSTATUSEX);
    if (GlobalMemoryStatusEx(&memInfo)) {
        char temp[500];
        
        strcat(buffer, "<table border='1' style='border-collapse: collapse; width: 100%;'>\n");
        strcat(buffer, "<tr><th>√ñzellik</th><th>Deƒüer</th></tr>\n");
        
        sprintf(temp, "<tr><td>Toplam Fiziksel Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullTotalPhys / (1024*1024*1024));
        strcat(buffer, temp);
        
        sprintf(temp, "<tr><td>Kullanƒ±labilir Fiziksel Bellek</td><td>%.2f GB</td></tr>\n", 
                (double)memInfo.ullAvailPhys / (1024*1024*1024));
        strcat(buffer, temp);
        
        sprintf(temp, "<tr><td>Bellek Kullanƒ±m Oranƒ±</td><td>%d%%</td></tr>\n", 
                memInfo.dwMemoryLoad);
        strcat(buffer, temp);
        
        strcat(buffer, "</table>\n");
    }
    
    strcat(buffer, "</div>\n");
}

void get_disk_info_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    strcat(buffer, "<table border='1' style='border-collapse: collapse; width: 100%;'>\n");
    strcat(buffer, "<tr><th>S√ºr√ºc√º</th><th>Toplam Alan</th><th>Bo≈ü Alan</th><th>Kullanƒ±m Oranƒ±</th></tr>\n");
    
    DWORD drives = GetLogicalDrives();
    char driveLetter = 'A';
    
    for (int i = 0; i < 26; i++) {
        if (drives & (1 << i)) {
            char drive[4];
            sprintf(drive, "%c:\\", driveLetter + i);
            
            ULARGE_INTEGER freeBytesAvailable, totalNumberOfBytes, totalNumberOfFreeBytes;
            
            if (GetDiskFreeSpaceEx(drive, &freeBytesAvailable, &totalNumberOfBytes, &totalNumberOfFreeBytes)) {
                double totalGB = (double)totalNumberOfBytes.QuadPart / (1024*1024*1024);
                double freeGB = (double)totalNumberOfFreeBytes.QuadPart / (1024*1024*1024);
                double usedGB = totalGB - freeGB;
                double usagePercent = (usedGB / totalGB) * 100;
                
                char temp[300];
                sprintf(temp, "<tr><td>%s</td><td>%.2f GB</td><td>%.2f GB</td><td>%.1f%%</td></tr>\n",
                        drive, totalGB, freeGB, usagePercent);
                strcat(buffer, temp);
            }
        }
    }
    
    strcat(buffer, "</table>\n");
    strcat(buffer, "</div>\n");
}

void get_network_info_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    strcat(buffer, "<h3>Aƒü Aray√ºzleri:</h3>\n");
    strcat(buffer, "<pre>\n");
    
    // This would normally contain network interface information
    // For now, we'll add a placeholder
    strcat(buffer, "Aƒü aray√ºz bilgileri burada g√∂r√ºnt√ºlenecek...\n");
    strcat(buffer, "IP yapƒ±landƒ±rmasƒ±, DNS ayarlarƒ±, aƒü baƒülantƒ± durumu vb.\n");
    
    strcat(buffer, "</pre>\n");
    strcat(buffer, "</div>\n");
}

void get_process_info_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    strcat(buffer, "<pre>\n");
    
    // This would normally contain top processes information
    strcat(buffer, "En √ßok kaynak kullanan s√ºre√ßler burada listelenecek...\n");
    
    strcat(buffer, "</pre>\n");
    strcat(buffer, "</div>\n");
}

void get_log_analysis_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    
    // Check if log files exist and analyze them
    FILE* logFile = fopen("logs/automation_center.log", "r");
    if (logFile) {
        int infoCount = 0, warningCount = 0, errorCount = 0;
        char line[1024];
        
        while (fgets(line, sizeof(line), logFile)) {
            if (strstr(line, "[INFO]")) infoCount++;
            else if (strstr(line, "[WARNING]")) warningCount++;
            else if (strstr(line, "[ERROR]")) errorCount++;
        }
        
        fclose(logFile);
        
        char temp[500];
        sprintf(temp, "<p><strong>Log Analizi:</strong></p>\n");
        strcat(buffer, temp);
        
        sprintf(temp, "<p>INFO mesajlarƒ±: %d</p>\n", infoCount);
        strcat(buffer, temp);
        
        sprintf(temp, "<p>WARNING mesajlarƒ±: %d</p>\n", warningCount);
        strcat(buffer, temp);
        
        sprintf(temp, "<p>ERROR mesajlarƒ±: %d</p>\n", errorCount);
        strcat(buffer, temp);
    } else {
        strcat(buffer, "<p>Log dosyasƒ± bulunamadƒ±.</p>\n");
    }
    
    strcat(buffer, "</div>\n");
}

void get_backup_status_for_report(char* buffer, int bufferSize) {
    strcpy(buffer, "<div class='info-box'>\n");
    
    // Check backup directory
    WIN32_FIND_DATA findFileData;
    HANDLE hFind;
    char searchPath[MAX_PATH_LEN];
    
    sprintf(searchPath, "backups\\*");
    hFind = FindFirstFile(searchPath, &findFileData);
    
    if (hFind == INVALID_HANDLE_VALUE) {
        strcat(buffer, "<p>Hen√ºz yedekleme yapƒ±lmamƒ±≈ü.</p>\n");
    } else {
        int backupCount = 0;
        LARGE_INTEGER totalSize;
        totalSize.QuadPart = 0;
        
        do {
            if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                backupCount++;
                LARGE_INTEGER fileSize;
                fileSize.LowPart = findFileData.nFileSizeLow;
                fileSize.HighPart = findFileData.nFileSizeHigh;
                totalSize.QuadPart += fileSize.QuadPart;
            }
        } while (FindNextFile(hFind, &findFileData) != 0);
        
        FindClose(hFind);
        
        char temp[300];
        sprintf(temp, "<p><strong>Toplam Yedek Dosyasƒ±:</strong> %d</p>\n", backupCount);
        strcat(buffer, temp);
        
        sprintf(temp, "<p><strong>Toplam Yedek Boyutu:</strong> %.2f MB</p>\n", 
                (double)totalSize.QuadPart / (1024*1024));
        strcat(buffer, temp);
    }
    
    strcat(buffer, "</div>\n");
}